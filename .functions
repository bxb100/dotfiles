#!/usr/bin/env bash

# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$_" || exit
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')" || exit
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
	local tmpFile
	tmpFile="${@%/}.tar"
	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

	size=$(
		stat -f"%z" "${tmpFile}" 2>/dev/null # macOS `stat`
		stat -c"%s" "${tmpFile}" 2>/dev/null # GNU `stat`
	)

	if ((size < 52428800)) && hash zopfli 2>/dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli"
	else
		if hash pigz 2>/dev/null; then
			cmd="pigz"
		else
			cmd="gzip"
		fi
	fi

	echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…"
	"${cmd}" -v "${tmpFile}" || return 1
	[ -f "${tmpFile}" ] && rm "${tmpFile}"

	zippedSize=$(
		stat -f"%z" "${tmpFile}.gz" 2>/dev/null # macOS `stat`
		stat -c"%s" "${tmpFile}.gz" 2>/dev/null # GNU `stat`
	)

	echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully."
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null >/dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n "$*" ]]; then
		du $arg -- "$@"
	else
		du $arg .[^.]* ./*
	fi
}

# Use Git’s colored diff when available
function diff() {
	if command -v git >/dev/null; then
		git diff --no-index --color-words "$@"
	else
		echo "ERROR: git is not installed. Please install git to use this function."
		return 1
	fi
}

# Create a data URL from a file
function dataurl() {
	local mimeType
	mimeType=$(file -b --mime-type "$1")
	if [[ $mimeType == text/* ]]; then
		mimeType="${mimeType};charset=utf-8"
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-8000}"
	sleep 1 && open "http://localhost:${port}/" &
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	http-server --port "${port}"
	# python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port";
}

# Compare original and gzipped file size
function gz() {
	origsize=$(wc -c <"$1")
	gzipsize=$(gzip -c "$1" | wc -c)
	ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l)
	printf "orig: %d bytes\n" "$origsize"
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Run `dig` and display the most useful info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# A function to retrieve Common Name (CN) and Subject Alternative Names (SANs)
# from a domain's SSL certificate.
function getcertnames() {
  # 1. Validate input
  if [ -z "${1}" ]; then
    echo "ERROR: No domain specified." >&2
    echo "Usage: getcertnames <domain>" >&2
    return 1
  fi

  local domain="${1}"
  echo "Testing ${domain}…"

  # 2. Retrieve certificate text in one pipeline, more efficiently.
  #    - Use <<<"" to close s_client connection cleanly without sending HTTP requests.
  #    - Pipe directly to x509 to avoid intermediate variables.
  #    - Use -noout with -text to only output the text version.
  #    - Redirect s_client stderr to /dev/null to hide connection info.
  local cert_text
  cert_text=$(openssl s_client -connect "${domain}:443" -servername "${domain}" <<<"" 2>/dev/null |
              openssl x509 -noout -text)

  # 3. Check if the certificate text was successfully retrieved
  if [ -z "${cert_text}" ]; then
    echo "ERROR: Failed to retrieve or parse certificate from ${domain}." >&2
    return 1
  fi

  # 4. Use awk for more robust and efficient parsing
  echo "${cert_text}" | awk '
    /Subject:.*CN/ {
      # Extract the Common Name (CN)

      if (match($0, /CN=([^\/]+)/)) {
        print "\nCommon Name:";
        print substr($0, RSTART + 3, RLENGTH);
      }
    }
    /Subject Alternative Name/ {
      # The SANs are on the next line, so we use getline
      getline;
      # Remove all whitespace and "DNS:" prefixes
      gsub(/DNS:| /, "");
      # Replace commas with newlines
      gsub(/,/, "\n");
      print "\nSubject Alternative Name(s):";
      print;
    }
  '

  return 0
}

# Normalize `open` across Linux, macOS, and Windows.
# This is needed to make the `o` function (see below) cross-platform.
if [ ! "$(uname -s)" = 'Darwin' ]; then
	if grep -q Microsoft /proc/version; then
		# Ubuntu on Windows using the Linux subsystem
		alias open='explorer.exe'
	else
		alias open='xdg-open'
	fi
fi

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o() {
	if [ $# -eq 0 ]; then
		open .
	else
		open "$@"
	fi
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
	tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX
}

# Checksum.sh is a simple way to download, review, and verify install scripts. If the checksum is OK the script will be printed to stdout, which can be piped to sh or elsewhere. If the checksum doesn't match it produces an error and nothing is piped.
# For example, to install Rust:
# checksum https://sh.rustup.rs 8327fa6ce106d2a387fdd02cb95c3607193c2edb | sh
# source: https://github.com/gavinuhma/checksum.sh
function checksum() {
	local s
	s=$(curl -fsSL "$1")
	local h
	if command -v shasum >/dev/null; then
		h=shasum
	else
		h=sha1sum
	fi
	if [ ! "$2" ]; then
		printf %s\\n "$s" | "$h" | awk '{print $1}'
		return 1
	fi
	printf %s\\n "$s" | "$h" --check --status <(printf '%s  -\n' "$2") || {
		echo "checksum failed" >&2
		return 1
	}
	printf %s\\n "$s"
}

# Update all git repositories under the current path
function gitup() {
	function up() {
		if [ -d "$1/.git" ]; then
			echo "Updating $1…"
			cd "$1" || exit
			git pull --prune
		fi
	}
	up "$PWD"
	for d in "${PWD}"/*/; do
		up "$d"
	done
}

function earse-target() {
	for d in "${PWD}"/*/; do
		if [ -d "$d/target" ]; then
			echo "Cleaning target $d…"
			(
				cd "$d" || exit
				/bin/rm -rf target
			)
		fi
	done
}

# function cargo-update() {
	# https://github.com/rust-lang/cargo/issues/9527
# 	cargo install "$(cargo install --list | grep -E '^[a-z0-9_-]+ v[0-9.]+:$' | cut -f1 -d' ')"
# }

function mavenclean() {
	# https://stackoverflow.com/questions/5074063/maven-error-failure-to-transfer
	find ~/.m2 -name "*.lastUpdated" -exec grep -q "Could not transfer" {} \; -print -exec rm {} \;
}

function md() {
	mkdir -p "$1" && cd "$1" || exit
}

function openg() {
	local repo
	if [[ -d '.jj' ]]; then
		repo=$(jj git remote list | awk 'NR==1 {print $2}')
	fi
	gh repo view "$repo" -w
}

function gradleclean() {
	# https://github.com/gradle/gradle/issues/2304
	find ~/.gradle/caches -type f -atime +30 -delete -print
	find ~/.gradle/caches -type d -mindepth 1 -empty -delete -print
}

preview() {
  # 1. Check if a file path was provided as an argument
  if [ -z "$1" ]; then
    echo "Usage: preview <file>"
    return 1
  fi

  # 2. Check if the file actually exists
  if [ ! -f "$1" ]; then
    echo "File not found: $1"
    return 1
  fi

  # 3. Check if the file has a .md extension
  if [[ "$1" == *.md ]]; then
    # 4. Check if the 'glow' command is available
    if command -v glow &> /dev/null; then
      glow -p "$1"
    else
      # Fallback if glow is not installed
      echo "'glow' not found, falling back to 'bat'."
      bat "$1"
    fi
  else
    # 5. Use 'bat' for any other file type
    bat "$1"
  fi
}
