#!/usr/bin/env bash

# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$_" || exit
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')" || exit
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
	local tmpFile
	tmpFile="${@%/}.tar"
	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

	size=$(
		stat -f"%z" "${tmpFile}" 2>/dev/null # macOS `stat`
		stat -c"%s" "${tmpFile}" 2>/dev/null # GNU `stat`
	)

	if ((size < 52428800)) && hash zopfli 2>/dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli"
	else
		if hash pigz 2>/dev/null; then
			cmd="pigz"
		else
			cmd="gzip"
		fi
	fi

	echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…"
	"${cmd}" -v "${tmpFile}" || return 1
	[ -f "${tmpFile}" ] && rm "${tmpFile}"

	zippedSize=$(
		stat -f"%z" "${tmpFile}.gz" 2>/dev/null # macOS `stat`
		stat -c"%s" "${tmpFile}.gz" 2>/dev/null # GNU `stat`
	)

	echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully."
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null >/dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n "$*" ]]; then
		du $arg -- "$@"
	else
		du $arg .[^.]* ./*
	fi
}

# Use Git’s colored diff when available
function diff() {
	if command -v git >/dev/null; then
		git diff --no-index --color-words "$@"
	else
		echo "ERROR: git is not installed. Please install git to use this function."
		return 1
	fi	
}

# Create a data URL from a file
function dataurl() {
	local mimeType
	mimeType=$(file -b --mime-type "$1")
	if [[ $mimeType == text/* ]]; then
		mimeType="${mimeType};charset=utf-8"
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-8000}"
	sleep 1 && open "http://localhost:${port}/" &
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	http-server --port "${port}"
	# python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port";
}

# Compare original and gzipped file size
function gz() {
	origsize=$(wc -c <"$1")
	gzipsize=$(gzip -c "$1" | wc -c)
	ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l)
	printf "orig: %d bytes\n" "$origsize"
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Run `dig` and display the most useful info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
	if [ -z "${1}" ]; then
		echo "ERROR: No domain specified."
		return 1
	fi

	local domain="${1}"
	echo "Testing ${domain}…"
	echo "" # newline

	tmp=$(echo -e "GET / HTTP/1.0\nEOT" |
		openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1)

	if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
		certText=$(echo "${tmp}" |
			openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
			no_serial, no_sigdump, no_signame, no_validity, no_version")
		echo "Common Name:"
		echo "" # newline
		echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//"
		echo "" # newline
		echo "Subject Alternative Name(s):"
		echo "" # newline
		echo "${certText}" | grep -A 1 "Subject Alternative Name:" |
			sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
		return 0
	else
		echo "ERROR: Certificate not found."
		return 1
	fi
}

# Normalize `open` across Linux, macOS, and Windows.
# This is needed to make the `o` function (see below) cross-platform.
if [ ! "$(uname -s)" = 'Darwin' ]; then
	if grep -q Microsoft /proc/version; then
		# Ubuntu on Windows using the Linux subsystem
		alias open='explorer.exe'
	else
		alias open='xdg-open'
	fi
fi

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o() {
	if [ $# -eq 0 ]; then
		open .
	else
		open "$@"
	fi
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
	tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX
}

# Checksum.sh is a simple way to download, review, and verify install scripts. If the checksum is OK the script will be printed to stdout, which can be piped to sh or elsewhere. If the checksum doesn't match it produces an error and nothing is piped.
# For example, to install Rust:
# checksum https://sh.rustup.rs 8327fa6ce106d2a387fdd02cb95c3607193c2edb | sh
# source: https://github.com/gavinuhma/checksum.sh
function checksum() {
	local s
	s=$(curl -fsSL "$1")
	local h
	if command -v shasum >/dev/null; then
		h=shasum
	else
		h=sha1sum
	fi
	if [ ! "$2" ]; then
		printf %s\\n "$s" | "$h" | awk '{print $1}'
		return 1
	fi
	printf %s\\n "$s" | "$h" --check --status <(printf '%s  -\n' "$2") || {
		echo "checksum failed" >&2
		return 1
	}
	printf %s\\n "$s"
}

# Update all git repositories under the current path
function gitup() {
	for d in "${PWD}"/*/; do
		if [ -d "$d/.git" ]; then
			echo "Updating $d…"
			(
				cd "$d" || exit
				git pull --prune
			)
		fi
	done
}

function earse-target() {
	for d in "${PWD}"/*/; do
		if [ -d "$d/target" ]; then
			echo "Cleaning target $d…"
			(
				cd "$d" || exit
				/bin/rm -rf target
			)
		fi
	done
}

function cargo-update() {
	# https://github.com/rust-lang/cargo/issues/9527
	cargo install "$(cargo install --list | grep -E '^[a-z0-9_-]+ v[0-9.]+:$' | cut -f1 -d' ')"
}

function mavenclean() {
	# https://stackoverflow.com/questions/5074063/maven-error-failure-to-transfer
	find ~/.m2 -name "*.lastUpdated" -exec grep -q "Could not transfer" {} \; -print -exec rm {} \;
}

function md() {
	mkdir -p "$1" && cd "$1" || exit
}

function openg() {
	local repo
	if [[ -d '.jj' ]]; then
		repo=$(jj git remote list | awk 'NR==1 {print $2}')
	fi
	gh repo view "$repo" -w
}

function gradleclean() {
	# https://github.com/gradle/gradle/issues/2304
	find ~/.gradle/caches -type f -atime +30 -delete -print
	find ~/.gradle/caches -type d -mindepth 1 -empty -delete -print
}
